nrow,language_id,algorithm_id,content
43,8,13,"<?php\n\nclass Queue {\n    protected $queue;\n\n    public function __construct() {\n        $this->queue = [];\n    }\n\n    public function isEmpty() {\n        return empty($this->queue);\n    }\n\n    public function enqueue($item) {\n        array_push($this->queue, $item);\n    }\n\n    public function dequeue() {\n        if (!$this->isEmpty()) {\n            return array_shift($this->queue);\n        }\n        return null;\n    }\n\n    public function size() {\n        return count($this->queue);\n    }\n}\n\n// Example usage\n$queue = new Queue();\n$queue->enqueue(\"John\");\n$queue->enqueue(\"Jane\");\n$queue->enqueue(\"Bob\");\n\necho \"Queue size: \" . $queue->size() . \"\\n\";\necho \"Dequeued item: \" . $queue->dequeue() . \"\\n\";\necho \"Queue size after dequeue: \" . $queue->size() . \"\\n\";\n\n?>"
39,5,10,"#include <stdio.h>\n\nvoid insertionSort(int arr[], int n) {\n    int i, key, j;\n    for (i = 1; i < n; i++) {\n        key = arr[i];\n        j = i - 1;\n \n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nvoid printArray(int arr[], int n) {\n    int i;\n    for (i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = { 64, 34, 25, 12, 22, 11, 90 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"Original array: \");\n    printArray(arr, n);\n\n    insertionSort(arr, n);\n\n    printf(\"Sorted array: \");\n    printArray(arr, n);\n\n    return 0;\n}\n"
34,13,12,"module Main where\n\ndata Stack a = EmptyStack | Stack a (Stack a) deriving Show\n\n-- Push an element onto the stack\npush :: a -> Stack a -> Stack a\npush x stack = Stack x stack\n\n-- Pop the top element from the stack\npop :: Stack a -> Maybe (a, Stack a)\npop EmptyStack = Nothing\npop (Stack x rest) = Just (x, rest)\n\n-- Check if the stack is empty\nisEmpty :: Stack a -> Bool\nisEmpty EmptyStack = True\nisEmpty _ = False\n\n-- Get the top element of the stack without removing it\ntop :: Stack a -> Maybe a\ntop EmptyStack = Nothing\ntop (Stack x _) = Just x\n\nmain :: IO ()\nmain = do\n    let stack = push 1 (push 2 (push 3 EmptyStack))\n    print stack\n    print (top stack)\n    let stackAfterPop = case pop stack of\n                            Just (_, s) -> s\n                            Nothing -> EmptyStack\n    print stackAfterPop\n    print (isEmpty stackAfterPop)\n"
60,7,5,"using System;\n\nclass UnionFind\n{\n    private int[] parent;\n    private int[] rank;\n\n    public UnionFind(int n)\n    {\n        parent = new int[n];\n        rank = new int[n];\n\n        for (int i = 0; i < n; i++)\n        {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    public int Find(int x)\n    {\n        if (parent[x] != x)\n        {\n            parent[x] = Find(parent[x]);\n        }\n\n        return parent[x];\n    }\n\n    public void Union(int x, int y)\n    {\n        int rootX = Find(x);\n        int rootY = Find(y);\n\n        if (rootX == rootY)\n        {\n            return;\n        }\n\n        if (rank[rootX] < rank[rootY])\n        {\n            parent[rootX] = rootY;\n        }\n        else if (rank[rootX] > rank[rootY])\n        {\n            parent[rootY] = rootX;\n        }\n        else\n        {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n       "
