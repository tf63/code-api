nrow,language_id,algorithm_id,content
43,8,13,"<?php\n\nclass Queue {\n    protected $queue;\n\n    public function __construct() {\n        $this->queue = [];\n    }\n\n    public function isEmpty() {\n        return empty($this->queue);\n    }\n\n    public function enqueue($item) {\n        array_push($this->queue, $item);\n    }\n\n    public function dequeue() {\n        if (!$this->isEmpty()) {\n            return array_shift($this->queue);\n        }\n        return null;\n    }\n\n    public function size() {\n        return count($this->queue);\n    }\n}\n\n// Example usage\n$queue = new Queue();\n$queue->enqueue(\"John\");\n$queue->enqueue(\"Jane\");\n$queue->enqueue(\"Bob\");\n\necho \"Queue size: \" . $queue->size() . \"\\n\";\necho \"Dequeued item: \" . $queue->dequeue() . \"\\n\";\necho \"Queue size after dequeue: \" . $queue->size() . \"\\n\";\n\n?>"
39,5,10,"#include <stdio.h>\n\nvoid insertionSort(int arr[], int n) {\n    int i, key, j;\n    for (i = 1; i < n; i++) {\n        key = arr[i];\n        j = i - 1;\n \n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j = j - 1;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nvoid printArray(int arr[], int n) {\n    int i;\n    for (i = 0; i < n; i++)\n        printf(\"%d \", arr[i]);\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = { 64, 34, 25, 12, 22, 11, 90 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    printf(\"Original array: \");\n    printArray(arr, n);\n\n    insertionSort(arr, n);\n\n    printf(\"Sorted array: \");\n    printArray(arr, n);\n\n    return 0;\n}\n"
34,13,12,"module Main where\n\ndata Stack a = EmptyStack | Stack a (Stack a) deriving Show\n\n-- Push an element onto the stack\npush :: a -> Stack a -> Stack a\npush x stack = Stack x stack\n\n-- Pop the top element from the stack\npop :: Stack a -> Maybe (a, Stack a)\npop EmptyStack = Nothing\npop (Stack x rest) = Just (x, rest)\n\n-- Check if the stack is empty\nisEmpty :: Stack a -> Bool\nisEmpty EmptyStack = True\nisEmpty _ = False\n\n-- Get the top element of the stack without removing it\ntop :: Stack a -> Maybe a\ntop EmptyStack = Nothing\ntop (Stack x _) = Just x\n\nmain :: IO ()\nmain = do\n    let stack = push 1 (push 2 (push 3 EmptyStack))\n    print stack\n    print (top stack)\n    let stackAfterPop = case pop stack of\n                            Just (_, s) -> s\n                            Nothing -> EmptyStack\n    print stackAfterPop\n    print (isEmpty stackAfterPop)\n"
60,7,5,"using System;\n\nclass UnionFind\n{\n    private int[] parent;\n    private int[] rank;\n\n    public UnionFind(int n)\n    {\n        parent = new int[n];\n        rank = new int[n];\n\n        for (int i = 0; i < n; i++)\n        {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    public int Find(int x)\n    {\n        if (parent[x] != x)\n        {\n            parent[x] = Find(parent[x]);\n        }\n\n        return parent[x];\n    }\n\n    public void Union(int x, int y)\n    {\n        int rootX = Find(x);\n        int rootY = Find(y);\n\n        if (rootX == rootY)\n        {\n            return;\n        }\n\n        if (rank[rootX] < rank[rootY])\n        {\n            parent[rootX] = rootY;\n        }\n        else if (rank[rootX] > rank[rootY])\n        {\n            parent[rootY] = rootX;\n        }\n        else\n        {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n       "
38,17,8,"module Main exposing (main)\n\nmergeSort : List comparable -> List comparable\nmergeSort list =\n    let\n        merge sorted1 sorted2 =\n            case ( sorted1, sorted2 ) of\n                ( [], l2 ) ->\n                    l2\n\n                ( l1, [] ) ->\n                    l1\n\n                ( front :: rest1, front2 :: rest2 ) ->\n                    if front < front2 then\n                        front :: merge rest1 sorted2\n                    else\n                        front2 :: merge sorted1 rest2\n    in\n        let\n            length = List.length list\n        in\n            if length <= 1 then\n                list\n            else\n                let\n                    ( half1, half2 ) = List.splitAt (length // 2) list\n                in\n                    merge (mergeSort half1) (mergeSort half2)\n\n\nmain : List comparable\nmain =\n    let\n        sortedList = mergeSort [ 8, 4, 1, 5, 2, 6, 3, 7 ]\n    in\n        sortedList\n"
8,1,14,"def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# Example usage\nprint(gcd(48, 18))  # Output: 6\n"
40,15,13,"class Queue {\n  List<int> _queue = [];\n\n  void enqueue(int value) {\n    _queue.add(value);\n  }\n\n  int dequeue() {\n    if (_queue.isNotEmpty) {\n      return _queue.removeAt(0);\n    } else {\n      throw Exception(\"Queue is empty\");\n    }\n  }\n\n  int peek() {\n    if (_queue.isNotEmpty) {\n      return _queue.elementAt(0);\n    } else {\n      throw Exception(\"Queue is empty\");\n    }\n  }\n\n  bool isEmpty() {\n    return _queue.isEmpty;\n  }\n}\n\nvoid main() {\n  Queue queue = Queue();\n\n  queue.enqueue(10);\n  queue.enqueue(20);\n  queue.enqueue(30);\n\n  print(\"Dequeued item: ${queue.dequeue()}\"); // Output: Dequeued item: 10\n  print(\"Peek item: ${queue.peek()}\"); // Output: Peek item: 20\n  print(\"Is empty? ${queue.isEmpty()}\"); // Output: Is empty? false\n}\n"
32,14,7,"fn quick_sort(arr: &mut [i32]) {\n    if arr.len() > 1 {\n        let pivot_index = partition(arr);\n        quick_sort(&mut arr[0..pivot_index]);\n        quick_sort(&mut arr[pivot_index + 1..]);\n    }\n}\n\nfn partition(arr: &mut [i32]) -> usize {\n    let pivot = arr[arr.len() - 1];\n    let mut i = 0;\n\n    for j in 0..arr.len() - 1 {\n        if arr[j] <= pivot {\n            arr.swap(i, j);\n            i += 1;\n        }\n    }\n\n    arr.swap(i, arr.len() - 1);\n    i\n}\n\nfn main() {\n    let mut arr = [64, 34, 25, 12, 22, 11, 90];\n    println!(\"Original array: {:?}\", arr);\n    \n    quick_sort(&mut arr);\n    \n    println!(\"Sorted array: {:?}\", arr);\n}\n"
40,6,9,"#include <iostream>\nusing namespace std;\n\nvoid selectionSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; ++i) {\n        int minIndex = i;\n\n        for (int j = i + 1; j < n; ++j) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n\n        // Swap arr[i] and arr[minIndex]\n        int temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n}\n\nint main() {\n    int arr[] = {64, 34, 25, 12, 22, 11, 90};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    cout << \"Original array: \";\n    for (int i = 0; i < n; ++i) {\n        cout << arr[i] << \" \";\n    }\n    \n    selectionSort(arr, n);\n    \n    cout << \"\\nSorted array: \";\n    for (int i = 0; i < n; ++i) {\n        cout << arr[i] << \" \";\n    }\n    \n    return 0;\n}\n"
40,3,13,"class Queue<T> {\n    private queue: T[];\n\n    constructor() {\n        this.queue = [];\n    }\n\n    enqueue(item: T): void {\n        this.queue.push(item);\n    }\n\n    dequeue(): T | undefined {\n        return this.queue.shift();\n    }\n\n    peek(): T | undefined {\n        return this.queue[0];\n    }\n\n    isEmpty(): boolean {\n        return this.queue.length === 0;\n    }\n\n    size(): number {\n        return this.queue.length;\n    }\n}\n\n// Example usage\nconst queue = new Queue<number>();\n\nqueue.enqueue(10);\nqueue.enqueue(20);\nqueue.enqueue(30);\n\nconsole.log('Size:', queue.size()); // Output: 3\nconsole.log('Dequeue:', queue.dequeue()); // Output: 10\nconsole.log('Peek:', queue.peek()); // Output: 20\nconsole.log('Is Empty:', queue.isEmpty()); // Output: false\n"
19,8,3,"&lt;?php\n\nfunction fibonacci($n) {\n    $fib = array();\n    $fib[0] = 0;\n    $fib[1] = 1;\n    \n    for ($i = 2; $i <= $n; $i++) {\n        $fib[$i] = $fib[$i - 1] + $fib[$i - 2];\n    }\n    \n    return $fib[$n];\n}\n\n// Example usage\n$n = 10;\necho \"Fibonacci number at position $n is: \" . fibonacci($n);\n\n?&gt;"
21,13,8,"merge :: Ord a => [a] -> [a] -> [a]\nmerge [] ys = ys\nmerge xs [] = xs\nmerge (x:xs) (y:ys) =\n    if x <= y\n        then x : merge xs (y:ys)\n        else y : merge (x:xs) ys\n\nmergeSort :: Ord a => [a] -> [a]\nmergeSort [] = []\nmergeSort [x] = [x]\nmergeSort xs =\n    let (left, right) = splitAt (length xs `div` 2) xs\n    in merge (mergeSort left) (mergeSort right)\n\nmain :: IO ()\nmain = do\n    let arr = [64, 34, 25, 12, 22, 11, 90]\n    putStrLn $ \"Original array: \" ++ show arr\n    putStrLn $ \"Sorted array: \" ++ show (mergeSort arr)\n"
40,8,11,"<pre>\nfunction heapify(array &$arr, int $n, int $i) {\n    $largest = $i;\n    $left = 2 * $i + 1;\n    $right = 2 * $i + 2;\n\n    // Check if left child is larger than root\n    if ($left < $n && $arr[$left] > $arr[$largest]) {\n        $largest = $left;\n    }\n\n    // Check if right child is larger than largest so far\n    if ($right < $n && $arr[$right] > $arr[$largest]) {\n        $largest = $right;\n    }\n\n    // If largest is not root\n    if ($largest != $i) {\n        $temp = $arr[$i];\n        $arr[$i] = $arr[$largest];\n        $arr[$largest] = $temp;\n\n        // Recursively heapify the affected sub-tree\n        heapify($arr, $n, $largest);\n    }\n}\n\nfunction heapSort(array &$arr) {\n    $n = count($arr);\n\n    // Build heap (rearrange array)\n    for ($i = (int)($n / 2) - 1; $i >= 0; $i--) {\n        heapify($arr, $n, $i);\n    }\n\n    // Extract elements from heap one by one\n    for ($i = $n - 1; $i >= 0; $i--) {\n        $temp = $arr[0];\n        $arr[0] = $arr[$i];\n        $arr[$i] = $temp"
63,6,5,"#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass UnionFind {\npublic:\n    UnionFind(int size) {\n        parent.resize(size);\n        rank.resize(size, 0);\n\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unite(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX != rootY) {\n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n        }\n    }\n\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n};\n\nint main() {\n    UnionFind uf(10);\n\n    uf.unite(0, 2);\n    uf.unite(1, 4);\n    uf.unite(3, 5);\n    uf.unite(2, 4);\n    uf.unite(6, 8);\n    uf.unite(7, 9);\n    uf.unite(7, 8);\n\n    cout << \"Parent array: \";\n    for (int i = 0; i < 10; i++) {\n        cout << uf.find(i) << \" \";\n    }\n\n    return 0;\n}\n"
65,2,5,"package main\n\nimport (\n\t\"fmt\"\n)\n\ntype UnionFind struct {\n\tparent []int\n\trank   []int\n\tcount  int\n}\n\nfunc NewUnionFind(size int) *UnionFind {\n\tuf := &UnionFind{\n\t\tparent: make([]int, size),\n\t\trank:   make([]int, size),\n\t\tcount:  size,\n\t}\n\n\tfor i := 0; i < size; i++ {\n\t\tuf.parent[i] = i\n\t\tuf.rank[i] = 1\n\t}\n\n\treturn uf\n}\n\nfunc (uf *UnionFind) Find(x int) int {\n\tif uf.parent[x] != x {\n\t\tuf.parent[x] = uf.Find(uf.parent[x])\n\t}\n\treturn uf.parent[x]\n}\n\nfunc (uf *UnionFind) Union(x int, y int) {\n\trootX := uf.Find(x)\n\trootY := uf.Find(y)\n\n\tif rootX == rootY {\n\t\treturn\n\t}\n\n\tif uf.rank[rootX] < uf.rank[rootY] {\n\t\tuf.parent[rootX] = rootY\n\t} else if uf.rank[rootX] > uf.rank[rootY] {\n\t\tuf.parent[rootY] = rootX\n\t} else {\n\t\tuf.parent[rootY] = rootX\n\t\tuf.rank[rootX]++\n\t}\n\n\tuf.count--\n}\n\nfunc main() {\n\tuf := NewUnionFind(5)\n\n\tuf.Union(0, 1)\n\tuf.Union(1, 2)\n\tuf.Union(3, 4)\n\n\tfmt.Println(uf.Count()) // Output: 2\n}\n\n"
10,1,14,"def gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\n# Example usage\nnum1 = 48\nnum2 = 18\nprint(f\"The GCD of {num1} and {num2} is: {gcd(num1, num2)}\")\n"
44,2,11,"package main\n\nimport \"fmt\"\n\nfunc heapSort(arr []int) {\n    n := len(arr)\n\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(arr, n, i)\n    }\n\n    for i := n - 1; i >= 0; i-- {\n        arr[0], arr[i] = arr[i], arr[0]\n        heapify(arr, i, 0)\n    }\n}\n\nfunc heapify(arr []int, n int, i int) {\n    largest := i\n    left := 2*i + 1\n    right := 2*i + 2\n\n    if left < n && arr[left] > arr[largest] {\n        largest = left\n    }\n\n    if right < n && arr[right] > arr[largest] {\n        largest = right\n    }\n\n    if largest != i {\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n    }\n}\n\nfunc main() {\n    arr := []int{12, 11, 13, 5, 6, 7}\n    fmt.Println(\"Original array:\", arr)\n\n    heapSort(arr)\n    fmt.Println(\"Sorted array:\", arr)\n}\n"
26,16,10,"defmodule InsertionSort do\n  def sort(list) do\n    sort(list, [])\n  end\n\n  defp sort([], sorted_list), do: Enum.reverse(sorted_list)\n  \n  defp sort([head | tail], sorted_list) do\n    sorted = insert(head, sorted_list)\n    sort(tail, sorted)\n  end\n\n  defp insert(element, [head | tail] = list) when element <= head do\n    [element | list]\n  end\n  \n  defp insert(element, [head | tail]) do\n    [head | insert(element, tail)]\n  end\nend\n\n# Example usage\nunsorted_list = [64, 34, 25, 12, 22, 11, 90]\nsorted_list = InsertionSort.sort(unsorted_list)\nIO.inspect(sorted_list)\n"
56,17,9,"module Main exposing (main)\n\nimport Array exposing (Array)\nimport Debug exposing (toString)\n\nselectionSort : List comparable -> List comparable\nselectionSort list =\n    let\n        arr = List.toArray list\n        len = Array.length arr\n    in\n    Array.toList <| selectionSortHelper arr len 0\n\n\nselectionSortHelper : Array comparable -> Int -> Int -> Array comparable\nselectionSortHelper arr len i =\n    if i < len then\n        let\n            minIndex = findMinIndex arr i (len - 1)\n            swappedArr = swap arr i minIndex\n        in\n        selectionSortHelper swappedArr len (i + 1)\n    else\n        arr\n\n\nfindMinIndex : Array comparable -> Int -> Int -> Int\nfindMinIndex arr start end =\n    let\n        minIndex = ref start\n        minValue = Array.get start arr\n        updateMinValueAndIndex index =\n            let\n                value = Array.get index arr\n            in\n            if value < minValue then\n                ( value, index )\n            else\n                ( minValue, minIndex )\n    in\n    Array.foldl updateMinValueAndIndex ( minValue, start ) (List.range start (end + 1)) -- Compare start to end\n\n\nswap : Array comparable -> Int -> Int -> Array comparable\nswap arr i j =\n    let\n        temp = Array.get i arr\n        updatedArr = Array.set i (Array.get j arr) arr\n    in\n    Array.set j temp updatedArr\n\n\nmain : Program () Model Msg\nmain =\n    let\n        sorted = selectionSort [ 64, 34, 25, 12, 22, "
70,7,5,"using System;\n\nclass UnionFind\n{\n    private int[] parent;\n    private int[] rank;\n\n    public UnionFind(int size)\n    {\n        parent = new int[size];\n        rank = new int[size];\n\n        for (int i = 0; i < size; i++)\n        {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    public int Find(int x)\n    {\n        if (x != parent[x])\n        {\n            parent[x] = Find(parent[x]);\n        }\n\n        return parent[x];\n    }\n\n    public void Union(int x, int y)\n    {\n        int rootX = Find(x);\n        int rootY = Find(y);\n\n        if (rootX == rootY)\n        {\n            return;\n        }\n\n        if (rank[rootX] < rank[rootY])\n        {\n            parent[rootX] = rootY;\n        }\n        else if (rank[rootX] > rank[rootY])\n        {\n            parent[rootY] = rootX;\n        }\n        else\n        {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        UnionFind uf = new UnionFind(5);\n\n        uf.Union(0, 2);\n        uf.Union(4, 2);\n        uf.Union(3, 1);\n\n        Console.WriteLine(uf.Find(4)); // Output: 0\n        Console.WriteLine(uf.Find(1)); // Output: 3\n    }\n}\n"
30,7,13,"using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Queue<string> queue = new Queue<string>();\n\n        // Enqueue elements in the queue\n        queue.Enqueue(\"Apple\");\n        queue.Enqueue(\"Banana\");\n        queue.Enqueue(\"Cherry\");\n\n        // Print the elements in the queue\n        foreach (string fruit in queue)\n        {\n            Console.WriteLine(fruit);\n        }\n\n        // Dequeue elements from the queue\n        string firstFruit = queue.Dequeue();\n        Console.WriteLine(\"Dequeued element: \" + firstFruit);\n\n        // Peek the front element in the queue\n        string frontFruit = queue.Peek();\n        Console.WriteLine(\"Front element: \" + frontFruit);\n    }\n}\n"
46,12,2,"class Graph\n  def initialize\n    @adj_list = {}\n  end\n\n  def add_edge(u, v)\n    @adj_list[u] ||= []\n    @adj_list[u] << v\n  end\n\n  def bfs(start)\n    visited = {}\n    queue = []\n\n    visited[start] = true\n    queue << start\n\n    while !queue.empty?\n      current = queue.shift\n      print \"#{current} \"\n\n      if @adj_list[current]\n        @adj_list[current].each do |neighbor|\n          unless visited[neighbor]\n            visited[neighbor] = true\n            queue << neighbor\n          end\n        end\n      end\n    end\n  end\nend\n\n# Example usage\ng = Graph.new\n\ng.add_edge('A', 'B')\ng.add_edge('A', 'C')\ng.add_edge('B', 'D')\ng.add_edge('C', 'E')\ng.add_edge('D', 'F')\ng.add_edge('E', 'F')\n\nputs \"Breadth First Traversal (starting from 'A'):\"\ng.bfs('A')\n"
52,6,2,"#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nclass Graph {\npublic:\n    void addEdge(int u, int v) {\n        adj[u].push_back(v);\n    }\n\n    void bfs(int start) {\n        vector<bool> visited(adj.size(), false);\n        queue<int> q;\n        visited[start] = true;\n        q.push(start);\n\n        while (!q.empty()) {\n            int current = q.front();\n            q.pop();\n\n            cout << current << \" \";\n\n            for (int neighbor : adj[current]) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    q.push(neighbor);\n                }\n            }\n        }\n    }\n\nprivate:\n    vector<vector<int>> adj;\n};\n\nint main() {\n    Graph g;\n\n    g.addEdge(0, 1);\n    g.addEdge(0, 2);\n    g.addEdge(1, 2);\n    g.addEdge(2, 0);\n    g.addEdge(2, 3);\n    g.addEdge(3, 3);\n\n    cout << \"Breadth First Traversal (starting from 2): \";\n    g.bfs(2);\n\n    return 0;\n}"
34,2,13,"package main\n\nimport \"fmt\"\n\ntype Queue struct {\n    elements []int\n}\n\nfunc (q *Queue) Enqueue(element int) {\n    q.elements = append(q.elements, element)\n}\n\nfunc (q *Queue) Dequeue() int {\n    if len(q.elements) == 0 {\n        return -1 // Error: Queue is empty\n    }\n    \n    front := q.elements[0]\n    q.elements = q.elements[1:]\n    return front\n}\n\nfunc main() {\n    q := Queue{}\n    q.Enqueue(10)\n    q.Enqueue(20)\n    q.Enqueue(30)\n    \n    fmt.Println(q.Dequeue()) // Output: 10\n    fmt.Println(q.Dequeue()) // Output: 20\n    fmt.Println(q.Dequeue()) // Output: 30\n    fmt.Println(q.Dequeue()) // Output: -1 (Error: Queue is empty)\n}\n"
24,2,3,"package main\n\nimport \"fmt\"\n\nfunc fibonacci(n int) int {\n    if n <= 1 {\n        return n\n    }\n\n    dp := make([]int, n+1)\n    dp[0] = 0\n    dp[1] = 1\n\n    for i := 2; i <= n; i++ {\n        dp[i] = dp[i-1] + dp[i-2]\n    }\n\n    return dp[n]\n}\n\nfunc main() {\n    fmt.Println(fibonacci(6)) // Output: 8\n}\n"
46,11,3,"import java.util.Arrays;\n\npublic class DynamicProgramming {\n\n    public static int fibonacci(int n) {\n        if (n <= 1) {\n            return n;\n        }\n\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = 1;\n\n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n\n        return dp[n];\n    }\n\n    public static int knapsack(int[] weights, int[] values, int capacity) {\n        int n = weights.length;\n        int[][] dp = new int[n + 1][capacity + 1];\n\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= capacity; j++) {\n                if (weights[i - 1] <= j) {\n                    dp[i][j] = Math.max(values[i - 1] + dp[i - 1][j - weights[i - 1]], dp[i - 1][j]);\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n\n        return dp[n][capacity];\n    }\n\n    public static void main(String[] args) {\n        // Fibonacci\n        int n = 6;\n        int fibonacciResult = fibonacci(n);\n        System.out.println(\"Fibonacci(\" + n + \") = \" + fibonacciResult);\n\n        // Knapsack\n        int[] weights = {2, 3, 4, 5};\n        int[] values = {3"
45,18,8,"function merge_sort(arr)\n    if length(arr) == 1\n        return arr\n    end\n    \n    mid = div(length(arr), 2)\n    left = merge_sort(arr[1:mid])\n    right = merge_sort(arr[mid+1:end])\n    \n    return merge(left, right)\nend\n\nfunction merge(left, right)\n    merged = []\n    i = 1\n    j = 1\n    \n    while i <= length(left) && j <= length(right)\n        if left[i] <= right[j]\n            push!(merged, left[i])\n            i += 1\n        else\n            push!(merged, right[j])\n            j += 1\n        end\n    end\n    \n    while i <= length(left)\n        push!(merged, left[i])\n        i += 1\n    end\n    \n    while j <= length(right)\n        push!(merged, right[j])\n        j += 1\n    end\n    \n    return merged\nend\n\n# Example usage\narr = [64, 34, 25, 12, 22, 11, 90]\nprintln(\"Original array: \", arr)\nprintln(\"Sorted array: \", merge_sort(arr))\n"
14,10,14,"import Foundation\n\nfunc gcd(_ a: Int, _ b: Int) -> Int {\n    if b == 0 {\n        return a\n    } else {\n        return gcd(b, a % b)\n    }\n}\n\n// Example usage\nlet result = gcd(48, 18)\nprint(\"GCD: \\(result)\") // Output: GCD: 6\n"
25,3,7,"function quickSort(arr: number[]): number[] {\n    if (arr.length <= 1) {\n        return arr;\n    } else {\n        const pivot = arr[0];\n        const left = [];\n        const right = [];\n\n        for (let i = 1; i < arr.length; i++) {\n            if (arr[i] < pivot) {\n                left.push(arr[i]);\n            } else {\n                right.push(arr[i]);\n            }\n        }\n\n        return [...quickSort(left), pivot, ...quickSort(right)];\n    }\n}\n\n// Example usage\nconst arr = [64, 34, 25, 12, 22, 11, 90];\nconsole.log(\"Original array: \" + arr);\nconsole.log(\"Sorted array: \" + quickSort(arr));\n"
65,7,8,"using System;\n\nclass MergeSort\n{\n    static void Merge(int[] arr, int left, int middle, int right)\n    {\n        int n1 = middle - left + 1;\n        int n2 = right - middle;\n\n        int[] leftArray = new int[n1];\n        int[] rightArray = new int[n2];\n\n        for (int i = 0; i < n1; ++i)\n        {\n            leftArray[i] = arr[left + i];\n        }\n\n        for (int j = 0; j < n2; ++j)\n        {\n            rightArray[j] = arr[middle + 1 + j];\n        }\n\n        int k = left;\n        int x = 0, y = 0;\n\n        while (x < n1 && y < n2)\n        {\n            if (leftArray[x] <= rightArray[y])\n            {\n                arr[k] = leftArray[x];\n                x++;\n            }\n            else\n            {\n                arr[k] = rightArray[y];\n                y++;\n            }\n            k++;\n        }\n\n        while (x < n1)\n        {\n            arr[k] = leftArray[x];\n            x++;\n            k++;\n        }\n\n        while (y < n2)\n        {\n            arr[k] = rightArray[y];\n            y++;\n            k++;\n        }\n    }\n\n    static void Sort(int[] arr, int left, int right)\n    {\n        if (left < right)\n        {\n            int middle = left + (right - left) / 2;\n\n            Sort(arr, left, middle);\n            Sort(arr, middle + 1, right);\n\n            Merge(arr, left, middle"
34,18,13,"struct Queue{T}\n    items::Vector{T}\nend\n\nfunction enqueue(queue::Queue{T}, item::T) where T\n    push!(queue.items, item)\n    return queue\nend\n\nfunction dequeue(queue::Queue{T}) where T\n    if isempty(queue.items)\n        throw(ArgumentError(\"Queue is empty\"))\n    end\n    return queue.items[1], Queue(queue.items[2:end])\nend\n\nfunction isempty(queue::Queue{T}) where T\n    return isempty(queue.items)\nend\n\nfunction length(queue::Queue{T}) where T\n    return length(queue.items)\nend\n\n# Example usage\nqueue = Queue{Int64}([])\n\nqueue = enqueue(queue, 1)\nqueue = enqueue(queue, 2)\nqueue = enqueue(queue, 3)\n\nprintln(dequeue(queue))  # Output: (1, Queue([2, 3]))\nprintln(length(queue))  # Output: 2\n"
23,18,10,"function insertionSort(arr::Array{T, 1}) where T\n    n = length(arr)\n    \n    for i in 2:n\n        key = arr[i]\n        j = i - 1\n        \n        while j >= 1 && arr[j] > key\n            arr[j+1] = arr[j]\n            j -= 1\n        end\n        \n        arr[j+1] = key\n    end\n    \n    return arr\nend\n\n# Example usage\narr = [64, 34, 25, 12, 22, 11, 90]\nprintln(\"Original array: \", arr)\nprintln(\"Sorted array: \", insertionSort(arr))\n"
36,16,13,"defmodule Queue do\n  defstruct front: [], rear: []\n\n  def empty?(queue) do\n    queue.front == [] and queue.rear == []\n  end\n\n  def enqueue(queue, element) do\n    %{queue | rear: queue.rear ++ [element]}\n  end\n\n  def dequeue(%{front: [], rear: rear} = queue) do\n    %{queue | front: Enum.reverse(rear), rear: []}\n  end\n\n  def dequeue(%{front: [h | t]} = queue) do\n    %{queue | front: t}\n  end\n\n  def peek(%{front: [h | _]}) do\n    h\n  end\nend\n\n# Example usage\nqueue = Queue.empty?()\nqueue = Queue.enqueue(queue, 1)\nqueue = Queue.enqueue(queue, 2)\nqueue = Queue.enqueue(queue, 3)\n\nIO.puts \"Dequeued element: #{Queue.peek(queue)}\"\nqueue = Queue.dequeue(queue)\nIO.puts \"Dequeued element: #{Queue.peek(queue)}\"\nqueue = Queue.dequeue(queue)\nIO.puts \"Dequeued element: #{Queue.peek(queue)}\"\n"
56,5,11,"#include <stdio.h>\n\nvoid swap(int* a, int* b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid heapify(int arr[], int n, int i) {\n    int largest = i;\n    int left = 2*i + 1;\n    int right = 2*i + 2;\n\n    if (left < n && arr[left] > arr[largest]) {\n        largest = left;\n    }\n\n    if (right < n && arr[right] > arr[largest]) {\n        largest = right;\n    }\n\n    if (largest != i) {\n        swap(&arr[i], &arr[largest]);\n        heapify(arr, n, largest);\n    }\n}\n\nvoid heapSort(int arr[], int n) {\n    for (int i = n/2 - 1; i >= 0; i--) {\n        heapify(arr, n, i);\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n        swap(&arr[0], &arr[i]);\n        heapify(arr, i, 0);\n    }\n}\n\nvoid printArray(int arr[], int n) {\n    for (int i = 0; i < n; i++) {\n        printf(\"%d \", arr[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int arr[] = {12, 11, 13, 5, 6, 7};\n    int n = sizeof(arr)/sizeof(arr[0]);\n\n    printf(\"Original array: \");\n    printArray(arr, n);\n\n    heapSort(arr, n);\n\n    printf"
21,15,6,"void bubbleSort(List<int> arr) {\n  int n = arr.length;\n  for (int i = 0; i < n - 1; i++) {\n    for (int j = 0; j < n - i - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        // Swap arr[j] and arr[j+1]\n        int temp = arr[j];\n        arr[j] = arr[j + 1];\n        arr[j + 1] = temp;\n      }\n    }\n  }\n}\n\nvoid main() {\n  List<int> arr = [64, 34, 25, 12, 22, 11, 90];\n  print('Original array: $arr');\n  bubbleSort(arr);\n  print('Sorted array: $arr');\n}\n"
53,10,2,"import Foundation\n\nclass Graph {\n    var adjacencyList: [Int: [Int]] = [:]\n    \n    func addEdge(_ u: Int, _ v: Int) {\n        if adjacencyList[u] == nil {\n            adjacencyList[u] = []\n        }\n        adjacencyList[u]?.append(v)\n        \n        if adjacencyList[v] == nil {\n            adjacencyList[v] = []\n        }\n        adjacencyList[v]?.append(u)\n    }\n    \n    func bfs(start: Int) {\n        var queue: [Int] = []\n        var visited: Set<Int> = []\n        \n        queue.append(start)\n        visited.insert(start)\n        \n        while !queue.isEmpty {\n            let vertex = queue.removeFirst()\n            print(vertex, terminator: \" \")\n            \n            if let neighbors = adjacencyList[vertex] {\n                for neighbor in neighbors {\n                    if !visited.contains(neighbor) {\n                        queue.append(neighbor)\n                        visited.insert(neighbor)\n                    }\n                }\n            }\n        }\n    }\n}\n\n// Example usage\nlet g = Graph()\n\ng.addEdge(0, 1)\ng.addEdge(0, 2)\ng.addEdge(1, 2)\ng.addEdge(2, 0)\ng.addEdge(2, 3)\ng.addEdge(3, 3)\n\nprint(\"Breadth First Traversal (starting from 2):\")\ng.bfs(start: 2)\n"
49,2,11,"package main\n\nimport (\n    \"fmt\"\n)\n\nfunc heapify(arr []int, n int, i int) {\n    largest := i\n    left := 2*i + 1\n    right := 2*i + 2\n\n    if left < n && arr[left] > arr[largest] {\n        largest = left\n    }\n\n    if right < n && arr[right] > arr[largest] {\n        largest = right\n    }\n\n    if largest != i {\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n    }\n}\n\nfunc heapSort(arr []int) {\n    n := len(arr)\n\n    // Build heap (rearrange array)\n    for i := n/2 - 1; i >= 0; i-- {\n        heapify(arr, n, i)\n    }\n\n    // One by one extract an element from heap\n    for i := n - 1; i >= 0; i-- {\n        arr[0], arr[i] = arr[i], arr[0]\n        heapify(arr, i, 0)\n    }\n}\n\nfunc main() {\n    arr := []int{12, 11, 13, 5, 6, 7}\n    fmt.Println(\"Original array: \", arr)\n  \n    heapSort(arr)\n  \n    fmt.Println(\"Sorted array: \", arr)\n}\n"
17,10,3,"func fibonacci(_ n: Int) -> Int {\n    var memo = [Int](repeating: 0, count: n + 1)\n    memo[0] = 0\n    memo[1] = 1\n    \n    for i in 2...n {\n        memo[i] = memo[i - 1] + memo[i - 2]\n    }\n    \n    return memo[n]\n}\n\n// Example usage\nlet n = 6\nlet result = fibonacci(n)\nprint(\"Fibonacci of \\(n): \\(result)\")\n"
32,6,12,"#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nint main() {\n    stack<int> st;\n\n    // Pushing elements into the stack\n    st.push(10);\n    st.push(20);\n    st.push(30);\n\n    // Checking if stack is empty\n    if (st.empty()) {\n        cout << \"Stack is empty!\" << endl;\n    } else {\n        cout << \"Stack is not empty!\" << endl;\n    }\n\n    // Accessing the top element of the stack\n    cout << \"Top element of stack: \" << st.top() << endl;\n\n    // Popping elements from the stack\n    while (!st.empty()) {\n        cout << \"Popped element: \" << st.top() << endl;\n        st.pop();\n    }\n\n    return 0;\n}\n"
24,7,14,"using System;\n\nclass Program\n{\n    static int GCD(int a, int b)\n    {\n        while (b != 0)\n        {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    static void Main(string[] args)\n    {\n        int a = 48;\n        int b = 18;\n        int gcd = GCD(a, b);\n        Console.WriteLine(\"GCD of {0} and {1} is {2}\", a, b, gcd);\n    }\n}\n"
51,11,5,"public class UnionFind {\n    private int[] parent;\n    private int[] size;\n\n    public UnionFind(int n) {\n        parent = new int[n];\n        size = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    public int find(int x) {\n        if (parent[x] == x) {\n            return x;\n        }\n        // Path compression\n        parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    public void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX != rootY) {\n            if (size[rootX] < size[rootY]) {\n                parent[rootX] = rootY;\n                size[rootY] += size[rootX];\n            } else {\n                parent[rootY] = rootX;\n                size[rootX] += size[rootY];\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        UnionFind uf = new UnionFind(5);\n\n        uf.union(0, 2);\n        uf.union(4, 2);\n        uf.union(3, 1);\n\n        // Find operations\n        System.out.println(uf.find(4)); // Output: 2\n        System.out.println(uf.find(0)); // Output: 2\n        System.out.println(uf.find(3)); // Output: 1\n        System.out.println(uf.find(1)); // Output: 1\n        System.out.println(uf"
29,10,4,"func binarySearch<T: Comparable>(_ array: [T], key: T) -> Int? {\n    var lowerBound = 0\n    var upperBound = array.count - 1\n    \n    while lowerBound <= upperBound {\n        let mid = (lowerBound + upperBound) / 2\n        \n        if array[mid] == key {\n            return mid\n        } else if array[mid] < key {\n            lowerBound = mid + 1\n        } else {\n            upperBound = mid - 1\n        }\n    }\n    \n    return nil\n}\n\n// Example usage\nlet numbers = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]\nlet searchKey = 50\n\nif let index = binarySearch(numbers, key: searchKey) {\n    print(\"Found at index \\(index)\")\n} else {\n    print(\"Not found\")\n}\n"
26,8,6,"&lt;?php\n\nfunction bubbleSort($arr) {\n    $n = count($arr);\n    \n    for ($i = 0; $i < $n - 1; $i++) {\n        for ($j = 0; $j < $n - $i - 1; $j++) {\n            if ($arr[$j] > $arr[$j + 1]) {\n                // Swap arr[j] and arr[j+1]\n                $temp = $arr[$j];\n                $arr[$j] = $arr[$j + 1];\n                $arr[$j + 1] = $temp;\n            }\n        }\n    }\n    \n    return $arr;\n}\n\n// Example usage\n$arr = array(64, 34, 25, 12, 22, 11, 90);\necho \"Original array: \";\nprint_r($arr);\necho \"Sorted array: \";\nprint_r(bubbleSort($arr));\n?&gt;"
15,17,14,"module Main exposing (..)\n\ngcd : Int -> Int -> Int\ngcd a b =\n    if b == 0 then\n        a\n    else\n        gcd b (a % b)\n\nmain =\n    let\n        result = gcd 48 18\n    in\n    Debug.log \"GCD: \" result\n"
31,8,4,"&lt;?php\n\nfunction binarySearch($arr, $target) {\n    $left = 0;\n    $right = count($arr) - 1;\n    \n    while ($left &lt;= $right) {\n        $mid = floor(($left + $right) / 2);\n        if ($arr[$mid] == $target) {\n            return $mid;\n        } elseif ($arr[$mid] &lt; $target) {\n            $left = $mid + 1;\n        } else {\n            $right = $mid - 1;\n        }\n    }\n    \n    return -1;\n}\n\n// Example usage\n$sortedArray = [2, 4, 6, 8, 10, 12, 14, 16];\n$target = 8;\n$result = binarySearch($sortedArray, $target);\nif ($result == -1) {\n    echo \"Element not found in array.\";\n} else {\n    echo \"Element found at index \" . $result . \".\";\n}\n\n?&gt;"
65,17,5,"module Main exposing (..)\n\nimport Dict exposing (Dict)\nimport List exposing (List)\nimport Set exposing (Set)\n\ntype alias UnionFind a =\n    { parent : Dict a a\n    , rank : Dict a Int\n    }\n\nempty : UnionFind a\nempty =\n    { parent = Dict.empty\n    , rank = Dict.empty\n    }\n\nfind : Ord a => a -> UnionFind a -> ( a, UnionFind a ) \nfind x uf =\n    let\n        root =\n            findRoot x uf\n\n        updatedUf =\n            { uf | parent = Dict.insert x root uf.parent }\n    in\n    ( root, updatedUf )\n\nfindRoot : Ord a => a -> UnionFind a -> a\nfindRoot x uf =\n    case Dict.get x uf.parent of\n        Just p ->\n            if p /= x then\n                let\n                    ( newRoot, updatedUf ) =\n                        find p uf\n                in\n                { updatedUf | parent = Dict.insert x newRoot uf.parent }\n                    |> findRoot x\n\n            else\n                x\n\n        Nothing ->\n            x\n\nunion : Ord a => a -> a -> UnionFind a -> UnionFind a\nunion x y uf =\n    let\n        ( rootX, updatedUf1 ) =\n            find x uf\n\n        ( rootY, updatedUf2 ) =\n            find y updatedUf1\n    in\n    if rootX /= rootY then\n        let\n            rankX =\n                Dict.get rootX uf.rank\n                    |> Maybe.withDefault 0\n\n            rankY =\n                Dict.get rootY uf.rank\n                    |> Maybe.withDefault 0\n"
25,3,4,"function binarySearch(arr: number[], target: number): number {\n    let start = 0;\n    let end = arr.length - 1;\n\n    while (start <= end) {\n        const mid = Math.floor((start + end) / 2);\n\n        if (arr[mid] === target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            start = mid + 1;\n        } else {\n            end = mid - 1;\n        }\n    }\n\n    return -1;\n}\n\n// Example usage\nconst arr = [2, 4, 7, 10, 14, 20];\nconst target = 10;\n\nconsole.log(\"The index of target in the array is: \" + binarySearch(arr, target));\n"
24,1,1,"def dfs(graph, start):\n    visited = set()\n    stack = [start]\n\n    while stack:\n        vertex = stack.pop()\n        if vertex not in visited:\n            visited.add(vertex)\n            print(vertex, end=\" \")\n            stack.extend(graph[vertex] - visited)\n\n# Example usage\ngraph = {\n    'A': set(['B', 'C']),\n    'B': set(['A', 'D']),\n    'C': set(['A', 'E']),\n    'D': set(['B', 'F']),\n    'E': set(['C', 'F']),\n    'F': set(['D', 'E'])\n}\n\nprint(\"Depth First Traversal (starting from 'A'):\")\ndfs(graph, 'A')\n"
29,10,9,"func selectionSort(_ array: [Int]) -> [Int] {\n    guard array.count > 1 else {\n        return array\n    }\n    \n    var mutableArray = array\n    \n    for currentIndex in 0..&lt;mutableArray.count - 1 {\n        var minimumIndex = currentIndex\n        \n        for i in currentIndex + 1..<mutableArray.count {\n            if mutableArray[i] &lt; mutableArray[minimumIndex] {\n                minimumIndex = i\n            }\n        }\n        \n        if minimumIndex != currentIndex {\n            mutableArray.swapAt(currentIndex, minimumIndex)\n        }\n    }\n    \n    return mutableArray\n}\n\n// Example usage\nlet array = [64, 34, 25, 12, 22, 11, 90]\nlet sortedArray = selectionSort(array)\nprint(\"Original array: \\(array)\")\nprint(\"Sorted array: \\(sortedArray)\")"
10,18,14,"function gcd(a, b)\n    if b == 0\n        return a\n    else\n        return gcd(b, a % b)\n    end\nend\n\nprintln(gcd(48, 18)) # Output: 6\n"
